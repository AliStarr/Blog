@inject IJSRuntime jsRuntime

<textarea class="@Class" id="@Id" rows="@Rows" @onkeyup="MarkShortDescription"
                       @oninput="args => Value = args.Value.ToString()">@Value</textarea>

@code {
    private string textContent = string.Empty;

    [Parameter]
    public string Value
    {
        get => textContent;
        set
        {
            if (textContent != value)
            {
                textContent = value;
                ValueChanged.InvokeAsync(value);
            }
        }
    }

    [Parameter]
    public EventCallback<string> ValueChanged { get; set; }

    [Parameter]
    public string Class { get; set; }

    [Parameter]
    public string Id { get; set; }

    [Parameter]
    public int Rows { get; set; }

    private async Task MarkShortDescription(KeyboardEventArgs keyboardEventArgs)
    {
        Value = await GetNewMarkdownForElementAsync(keyboardEventArgs, Value, Id);
        StateHasChanged();
    }

    private async Task<string> GetNewMarkdownForElementAsync(KeyboardEventArgs keyboardEventArgs, string original, string elementId)
    {
        return keyboardEventArgs.CtrlKey ? keyboardEventArgs.Key switch
        {
            "b" => await GetNewMarkdownForElementAsync(elementId, original, "**", "**"),
            "i" => await GetNewMarkdownForElementAsync(elementId, original, "*", "*"),
            _ => original,
            } : original;
    }

    private async Task<string> GetNewMarkdownForElementAsync(
        string elementId,
        string content,
        string fenceBegin,
        string fenceEnd)
    {
        var selectionRange = await jsRuntime.InvokeAsync<SelectionRange>("getSelectionFromElement", elementId);
        if (selectionRange.Start == selectionRange.End)
        {
            return content;
        }

        var beforeMarker = selectionRange.Start > 0 ? content[..selectionRange.Start] : string.Empty;
        var marker = content[selectionRange.Start..selectionRange.End];
        var afterMarker = content[selectionRange.End..];
        var shift = selectionRange.End + fenceBegin.Length + fenceEnd.Length;
        await jsRuntime.InvokeVoidAsync("setSelectionFromElement", elementId, shift);
        return beforeMarker + fenceBegin + marker + fenceEnd + afterMarker;
    }
}